## 동기식 입출력과 비동기식 입출력

![Untitled](https://www.notion.so/System-Structure-Program-Execution-2-5f65fc2f3c1943b1b706f588fff9faa8#bc71fcbe06314858ac383986141cddd2)

### 동기식 입출력 (Synchronous I/O)

---

- I/O를 요청한 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램으로 넘어가게 하는 것

= 사용자 프로그램(I/O 요청)  → device driver → 하드웨어를 통해 I/O를 읽고 쓰는 작업을 함

→ 그 작업이 완료된 후 사용자 프로그램이 작업을 진행하면 동기식 입출력이다. 

**두 가지의 구현 방법이 존재**

1.  I/O 가 끝날 때 까지 CPU를 낭비시킴 (매시점 하나의 I/O만 일어날 수 있음)
2.  I/O가 완료될 떄까지 해당 프로그램에게서 CPU를 빼앗음 → I/O 처리를 기다리는 중에 그 프로그램을 줄 세움 (다른 프로그램에게 CPU를 줌)

= 1번은 비효율적이기에 보통은 2번으로 구현하게 된다.

### 비동기식 입출력 (Asynchronous I/O)

---

- I/O가 시작된 후 입출력 작업이 완료되는 것을 기다리지 않고 제어가 사용자 프로그램으로 즉시 넘어감

= 사용자 프로그램(I/O 요청)  → device driver → 하드웨어를 통해 I/O를 읽고 쓰는 작업을 함

→ 그 작업이 완료되기 이전에, 사용자 프로그램이 작업을 진행하면 동기식 입출력이다.

***** 두 경우 모두 작업이 끝났다는 것을 Inturrupt를 통해 알려줌**

(이전에 설명했던 내용이지만, DMA를 통해 CPU로 거는 I/O Inturrupt를 바이트 단위가 아닌 block단위로 메모리에 가까운 속도로 처리할 수 있도록 도와준다.)

## 서로 다른 입출력 명령어

---

I/O를 수행하는 Special Instruction에 의한다면  - 일반적인 I/O  방식 

(Memory 에 접근하는 Instruction 따로, Device Address 에 접근하는 Special Instruction 따로 존재)

Memory Mapped I/O에 의한다면 - Memory Mapped I/O 방식

(Memory Address만을 이용, 연장 주소를 이용하여 주소값을 다르게 하여 접근하는 방식)

## 저장장치 계층 구조

### Primary (CPU에서 바로 접근할 수 있는 저장장치), 주로 휘발성

---

- Register
- Cache Memory - 당장 필요한 것만 메인 메모리에서 가져와 사용한다.

  ⇒ Cashing (재사용이 목적, 같은 것을 두번째 요청할 때에는 Cashing 된 데이터를 사용함)

- Main Memory (요즘에는 비휘발성도 되는 것을 만들기도 한다고 한다)

### Secondary (CPU에서 바로 접근할 수 없는 저장장치), 비휘발성

---

- Magnetic Disk
- Optical Disk
- Magnetic Tape

***** 위로 올라갈 수록 비싸며 빠르고 용량이 작다. 반대로 아래로 내려갈 수록 싸며 느리고 크다.**

## 프로그램의 실행(메모리 load)

---

프로그램을 실행하게되면 각 프로그램은 주소 공간을 가지게 되고 메모리에 상주하게된다.

- Stack - 프로그램 마다 kernel 스택을 따로 둠
- data - 프로그램을 관리하기 위한 자료구조가 존재 (PCB, Program Control Block)
- code - 프로그램에 관련된 코드 (ex_ OS는 자원 관리, 시스템콜, 인터럽트 관련한 코드가 존재)

각각 위와 같은 구성으로 이루어져 있고,

컴퓨터를 키면 가장 먼저 실행되는 OS(Kernel)은 항상 메모리에 상주하고 있게 된다.

후에 프로그램을 사용하지 않게되면 메모리에서 없애게 되고,

바로 없애면 안되는 데이터 같은 경우 Swap area를 이용하기도 한다. (**메모리 연장의 용도로 사용**)

## 사용자 프로그램이 사용하는 함수

### 함수(Function)

---

- 사용자 정의 함수 - 사용자가 자신의 프로그램에서 정의한 함수
- 라이브러리 함수 - 자신의 프로그램에서 정의하지 않고 가져다가 쓴 함수 (실행 파일에 포함)

- 커널 함수 = OS 프로그램의 함수 (커널 함수의 호출 = 시스템콜)

## 프로그램의 실행

---

각 주소공간에서 코드(함수)를 실행하기 위해서 아래와 같이 진행된다

**user mode →(System Call)→ kernel mode**

(단, Timer Inturrupt와 같은 요소는 배제함)

위와 같은 방법을 반복하며 프로그램이 User mode(사용자 프로그램),

 Kernel mode(운영체제)를 넘나들며 프로그램을 실행하게 된다.
